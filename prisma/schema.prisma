generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// ─── Better Auth Tables ──────────────────────────────────────

model User {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessions Session[]
  accounts Account[]

  // App-specific relations
  conversations Conversation[]
  channelLinks  ChannelLink[]
  memories      Memory[]
  skillConfigs  SkillConfig[]
  auditLogs     AuditLog[]
  mcpServers    McpServer[]
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt
}

// ─── Application Tables ──────────────────────────────────────

model Conversation {
  id        String   @id @default(cuid())
  title     String   @default("New Conversation")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId       String
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages     Message[]
  channelLinks ChannelLink[]
}

model Message {
  id        String   @id @default(cuid())
  role      String   // "user" | "assistant" | "system"
  content   String
  source    String?  // "web" | "telegram" | "discord" | "slack" | ... (null = web)
  metadata  String?  // JSON string for tool calls, memory refs, etc.
  createdAt DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}

/// Maps external platform channels to internal conversations so inbound
/// messages from different platforms share the same conversation context.
model ChannelLink {
  id             String   @id @default(cuid())
  platform       String   // "telegram" | "discord" | "slack" | ...
  externalId     String   // platform-specific chat/channel/thread ID
  createdAt      DateTime @default(now())

  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, platform, externalId])
}

model Memory {
  id        String   @id @default(cuid())
  type      String   // "short_term" | "long_term" | "episodic"
  content   String
  summary   String?
  tags      String?  // JSON array of tags
  ragDocId  String?  // Reference to document ID in LightRAG
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AppSettings {
  id    String @id @default("singleton") // single-row table
  // AI provider
  aiProvider      String?  // "openai" | "anthropic" | ... (null = use env)
  aiModel         String?  // "gpt-4o" | "anthropic/claude-..." (null = use env)
  // Provider API keys (encrypted at rest is the caller's responsibility)
  openaiApiKey        String?
  anthropicApiKey     String?
  googleAiApiKey      String?
  mistralApiKey       String?
  xaiApiKey           String?
  deepseekApiKey      String?
  moonshotApiKey      String?
  openrouterApiKey    String?
  perplexityApiKey    String?
  minimaxApiKey       String?
  glmApiKey           String?
  huggingfaceApiKey   String?
  vercelAiGatewayKey  String?
  // Optional base URL override
  openaiBaseUrl   String?
  // Embedding overrides
  embeddingProvider String?  // "openai" | "anthropic" | ... (null = same as LLM provider)
  embeddingModel    String?
  embeddingApiKey   String?
  embeddingBaseUrl  String?
  // Timestamps
  updatedAt DateTime @updatedAt
}

model SkillConfig {
  id        String   @id @default(cuid())
  skillId   String
  enabled   Boolean  @default(true)
  config    String?  // JSON config
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, skillId])
}

// ─── Gateway Pattern: Job Queue ─────────────────────────────

/// Persistent job queue backed by SQLite. Inbound webhook messages are
/// enqueued here so the HTTP handler can return immediately. A background
/// worker polls and processes jobs asynchronously.
model Job {
  id         String   @id @default(cuid())
  type       String   // "inbound_message" | "compact_conversation" | ...
  status     String   @default("pending") // "pending" | "processing" | "completed" | "failed"
  payload    String   // JSON
  result     String?  // JSON
  attempts   Int      @default(0)
  maxRetries Int      @default(3)
  error      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  userId String?

  @@index([status, createdAt])
}

// ─── Harness: Audit Log ─────────────────────────────────────

/// Records every tool call / skill execution for security auditing.
model AuditLog {
  id         String   @id @default(cuid())
  action     String   // "tool_call" | "skill_execute" | "memory_store" | ...
  skillId    String?
  input      String?  // JSON (sanitized)
  output     String?  // JSON (truncated)
  source     String?  // "web" | "telegram" | "agent" | ...
  durationMs Int?
  success    Boolean  @default(true)
  createdAt  DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
}

// ─── MCP Server Configuration ───────────────────────────────

/// Per-user MCP server configurations. Each row represents an external
/// MCP server that the user has configured (via the UI or API).
/// Global servers from the config file are NOT stored here.
model McpServer {
  id        String   @id @default(cuid())
  name      String
  transport String   // "stdio" | "http"
  command   String?  // stdio: command to spawn (e.g. "npx")
  args      String?  // JSON array of command arguments
  env       String?  // JSON object of environment variables
  url       String?  // http: server URL
  headers   String?  // JSON object of HTTP headers
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
}
